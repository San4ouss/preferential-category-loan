class RUNTIME;

@import_plsql(true)
@name('Библиотека работы с BLOB/CLOB')
static method LOB_UTILS is
/**
Библиотека для работы с CLOB и BLOB.
А также для организации обмена объемными текстовыми (CLOB) и бинарными (BLOB) данными между клиентом и сервером.
Функционал обмена LOB между клиентом и сервером позволяет:
- передавать текст из CLOB-переменной на сервере в текстовую переменную в клиент-скрипте
- передавать данные из BLOB-переменной на сервере в текстовую переменную в клиент-скрипте
- сохранять текст из CLOB-переменной на сервере в файл на клиенте
- передавать данные из BLOB-переменной на сервере в файл на клиенте
- передавать текст из переменной в клиент-скрипте в CLOB-переменную на сервере
- передавать данные из текстовую переменной в клиент-скрипте в BLOB-переменной на сервере
- загружать содержимое файла с клиента в CLOB-переменную на сервере
- загружать содержимое файла с клиента в BLOB-переменную на сервере
Примечание: основная разница при передаче между CLOB и BLOB заключается в применении транскодирования из/в кодировки сервера в/из кодировку клиента
Вызов передачи данных осуществляется из клиент-скрипта.
Для обработки данных, переданных на сервер или подготовки данных для передачи с сервера можно использовать вызов серверного валидатора из клиент-скрипта (Runtime.ServerValidate).
В сочетании с функциями file2clob, file2blob данной библиотеки можно организовать копирование файлов без использования контрола типа "Экспорт-импорт файлов" (FILE$LOAD).
В отличии от "Экспорт-импорт файлов" (FILE$LOAD), возможна передача данных без создания временных файлов.

Использование:
1. Создать текстовый параметр или переменную операции длиной не менее 32000 (например, V_LOB_BUFF)
2. На форме операции создать контрол, соответствующий созданному параметру или переменной (V_LOB_BUFF), задать идентификатор "LOBBuff"
3. В серверном валидаторе, в обработке P_MESSAGE = 'VALIDATE' вставить блок обработки сообщений обмена данными:
	if ::[RUNTIME].[LOB_UTILS].lob_check_validate_info(P_INFO) then
		::[RUNTIME].[LOB_UTILS].lob_validate(P_INFO, V_LOB_BUFF, vLOB);
	end if;
или	макрос:
	&LOB_VALIDATOR(V_LOB_BUFF, vLOB);
	где: V_LOB_BUFF - параметр или переменная, созданная в п. 1, а vLOB - переменная типа CLOB или BLOB (в зависимости от требований)
4. В клиент-скрипте подключить библиотеку LOB_UTILS:
	'#include ::[RUNTIME].[LOB_UTILS]
5.
	a. Для получения текстовых данных с сервера, в клиент-скрипте вызвать функцию GetCLOB
		Например, text = GetCLOB, в этом случае в переменную клиент-скрипта text будет передано содержимое указанной в серверном валидаторе CLOB-переменной (vLOB)
	b. Для получения бинарных данных с сервера, в клиент-скрипте вызвать функцию GetBLOB
		Например, data = GetBLOB, в этом случае в переменную клиент-скрипта text будет передано содержимое указанной в серверном валидаторе BLOB-переменной (vLOB) (без преобразования кодировки)
	c. Для передачи текстовых данных на сервер, в клиент-скрипте вызвать процедуру SetCLOB
		Например, SetCLOB(text), в этом случае в указанную в серверном валидаторе CLOB-переменную (vLOB) будет передано значение переменной клиент-скрипта text
	d. Для передачи текстовых данных на сервер, в клиент-скрипте вызвать процедуру SetBLOB
		Например, SetBLOB(data), в этом случае в указанную в серверном валидаторе BLOB-переменную (vLOB) будет передано значение переменной клиент-скрипта data (без преобразования кодировки)
	e. Для сохранения текстовых данных с сервера, в файл на клиенте вызвать функцию GetCLOBToFile
		Например, GetCLOBToFile("C:\tmp\data.txt"), в этом случае в файл на клиенте C:\tmp\data.txt будет передано содержимое указанной в серверном валидаторе CLOB-переменной (vLOB) (с преобразованием кодировки)
	f. Для сохранения бинарных данных с сервера, в файл на клиенте вызвать функцию GetBLOBToFile
		Например, GetBLOBToFile("C:\tmp\data.bin"), в этом случае в файл на клиенте C:\tmp\data.bin будет передано содержимое указанной в серверном валидаторе BLOB-переменной (vLOB)
	g. Для передачи содержимого файла на сервер в CLOB, в клиент-скрипте вызвать процедуру SetCLOBFromFile
		Например, SetCLOBFromFile("C:\tmp\data.txt"), в этом случае содержимое файла на клиенте C:\tmp\data.txt будет передано в указанную в серверном валидаторе CLOB-переменную (vLOB) (с преобразованием кодировки)
	h. Для передачи содержимого файла на сервер в BLOB, в клиент-скрипте вызвать процедуру SetBLOBFromFile
		Например, SetBLOBFromFile("C:\tmp\data.bin"), в этом случае содержимое файла на клиенте C:\tmp\data.bin будет передано в указанную в серверном валидаторе BLOB-переменную (vLOB)

Пример использования передачи данных на схеме разработки в операции ::[RD].[LOB_PASS]

Внимание!
При использовании механизма необходимо предварительно проверять размер передаваемых данных.
Размер сравнивается с ограничением, задаваемым настройкой LOB_UTILS_SIZE_LIM (FP_TUNE).
При превышении ограничения, должно выводиться предупреждение или отказ от передачи.
Для проверки ограничения реализованы глобальные функции PL+:
- check_size
- check_file_size
- check_dir_size
- check_file_list_size
а также, функции VBS:
- CheckSize
- CheckFileSize
- CheckFolderSize
- CheckFileListSize

*/

public pragma define(BASE64);

public pragma macro(LOB_BLOCK_SIZE, '31512'); -- размер блока данных (при передаче CLOB или в закодированном виде при передаче BLOB)
--#ifdef BASE64
public pragma macro(BIN_BLOCK_SIZE, '23634'); -- размер блока исходных данных при передаче BLOB в кодировке BASE64
--#else
public pragma macro(BIN_BLOCK_SIZE, '15756'); -- размер блока исходных данных при передаче BLOB в кодировке HEX
--#endif

-- *** Функции передачи данных ***

/**
Макрос для серверной валидации механизма передачи данных
Вставляется в секцию валидации
Пример секции проверка операции:
pragm include(::[RUNTIME].[LOB_UTILS]);
begin
	if P_MESSAGE = 'DEFAULT' then
		null;
	elsif P_MESSAGE = 'VALIDATE' then
		null;

		&LOB_VALIDATOR(P_LOB_BUFF, vBLOB);
	end if;
end;
*/
public pragma macro(LOB_VALIDATOR, 'if ::[RUNTIME].[LOB_UTILS].lob_check_validate_info(P_INFO) then ::[RUNTIME].[LOB_UTILS].lob_validate(P_INFO, [1], [2]); end if', substitute);

public type T_FILE_LIST is table of string(512);

pragma include(::[INTERFACE].[COMPILE_LIB]);
procedure check_api is
begin
	&check_api
end;

pragma include(::[RUNTIME].[MACRO_LIB]);

gBLOB BLOB;
gCLOB CLOB;
gLOB_len number;
gLOB_offs number;
gDB_NLS string := NULL;
gLOB_UTILS_size_limit number := NULL;

l_slash string(1);

-- *** Функции для работы с LOBами ***

/**
 * Определяет принадлежность кода валидации P_INFO к кодам сообщений передачи данных
 *
 * @param info	Код параметра валидации. При вызове нужно передавать P_INFO
 * @return		Признак принадлежности переданного значения к кодам сообщений передачи данных. Т.е. true означает, что валидация вызвана библиоткой передачи данных и нужно ее обработать (процедурой lob_validate).
 */
public function lob_check_validate_info(info string) return boolean is
begin
	return (info in ('__LU_BLOB_INIT_SEND', '__LU_BLOB_INIT_RECEIVE', '__LU_BLOB_SEND_BLOCK', '__LU_BLOB_RECEIVE_BLOCK', '__LU_BLOB_CLOSE_RECEIVE',
		'__LU_CLOB_INIT_SEND', '__LU_CLOB_INIT_RECEIVE', '__LU_CLOB_SEND_BLOCK', '__LU_CLOB_RECEIVE_BLOCK', '__LU_CLOB_CLOSE_RECEIVE'));
end;

-- инициализация отправки. загрузка BLOB
procedure blob_init(inBLOB BLOB := NULL) is
begin
	dbms_lob.createtemporary(gBLOB, true);
	gLOB_len := 0;
	if inBLOB is not NULL then
		gLOB_len := dbms_lob.getlength(inBLOB);
	end if;
	if inBLOB is not NULL and gLOB_len > 0 then
		dbms_lob.copy(gBLOB, inBLOB, gLOB_len);
	end if;
	gLOB_offs := 1;
end;
procedure clob_init(inCLOB CLOB := NULL) is
begin
	dbms_lob.createtemporary(gCLOB, true);
	gLOB_len := 0;
	if inCLOB is not NULL then
		gLOB_len := dbms_lob.getlength(inCLOB);
	end if;
	if inCLOB is not NULL and gLOB_len > 0 then
		dbms_lob.copy(gCLOB, inCLOB, gLOB_len);
	end if;
	gLOB_offs := 1;
end;

-- завершение отправки. освобождение BLOB
procedure blob_close is
begin
	dbms_lob.freetemporary(gBLOB);
	gLOB_len := 0;
	gLOB_offs := 1;
end;
-- завершение отправки. освобождение BLOB
procedure blob_close(outBLOB in out nocopy BLOB) is
	len number;
begin
	len := dbms_lob.getlength(gBLOB);
	dbms_lob.trim(outBLOB, 0);
	if len > 0 then
		dbms_lob.copy(outBLOB, gBLOB, len);
	end if;
	blob_close;
end;
-- завершение отправки. освобождение CLOB
procedure clob_close is
begin
	dbms_lob.freetemporary(gCLOB);
	gLOB_len := 0;
	gLOB_offs := 1;
end;
-- завершение отправки. освобождение CLOB
procedure clob_close(outCLOB in out nocopy CLOB) is
	len number;
begin
	len := dbms_lob.getlength(gCLOB);
	dbms_lob.trim(outCLOB, 0);
	if len > 0 then
		dbms_lob.copy(outCLOB, gCLOB, len);
	end if;
	clob_close;
end;

-- передать следующий блок на клиента
procedure blob_send_next_block(buff out string) is
	sz number := &BIN_BLOCK_SIZE;
	r raw(&BIN_BLOCK_SIZE);
begin
	buff := NULL;
	if gLOB_offs <= gLOB_len then
		dbms_lob.read(gBLOB, sz, gLOB_offs, r);
		if sz > 0 then -- успешно
			--#ifdef BASE64
			buff := translate(utl_raw.cast_to_varchar2(utl_encode.base64_encode(r)), ' ' || NL$, ' ');
			--#else
			buff := rawtohex(r);
			--#endif
			gLOB_offs := gLOB_offs + sz;
		end if;
	end if;
end;
-- передать следующий блок на клиента
procedure clob_send_next_block(buff out string) is
	sz number := &LOB_BLOCK_SIZE;
	s string(&LOB_BLOCK_SIZE);
begin
	buff := NULL;
	if gLOB_offs <= gLOB_len then
		dbms_lob.read(gCLOB, sz, gLOB_offs, s);
		if sz > 0 then -- успешно
			buff := s;
			gLOB_offs := gLOB_offs + sz;
		end if;
	end if;
end;

-- принять следующий блок от клиента
procedure blob_receive_next_block(buff string) is
	sz number;
	r raw(&BIN_BLOCK_SIZE);
begin
	if buff is not NULL then
		--#ifdef BASE64
		r := utl_encode.base64_decode(utl_raw.cast_to_raw(buff));
		--#else
		r := hextoraw(buff);
		--#endif
		sz := utl_raw.length(r);
		dbms_lob.writeappend(gBLOB, sz, r);
		gLOB_len := gLOB_len + sz;
		gLOB_offs := gLOB_offs + sz;
	end if;
end;
-- принять следующий блок от клиента
procedure clob_receive_next_block(buff string) is
	sz number;
begin
	if buff is not NULL then
		sz := length(buff);
		dbms_lob.writeappend(gCLOB, sz, buff);
		gLOB_len := gLOB_len + sz;
		gLOB_offs := gLOB_offs + sz;
	end if;
end;

/**
 * Обработка сообщения передачи данных (для передачи BLOB)
 *
 * @param info	Код параметра валидации. При вызове нужно передавать P_INFO
 * @param buff	Параметр или переменная операции, использующаяся для передачи блока данных (п. 1 в описании использования)
 * @param pBLOB	Переменная типа BLOB откуда будет считываться или сохраняться данные
 */
public procedure lob_validate(
	info string
	, buff in out nocopy string
	, pBLOB in out nocopy BLOB
	)
is
begin
	case info of
		:'__LU_BLOB_INIT_SEND':
			blob_init(pBLOB);
			gLOB_offs := 1;
			buff := nvl(to_char(dbms_lob.getlength(pBLOB)), '0');
		:'__LU_BLOB_INIT_RECEIVE':
			blob_init;
			buff := NULL;
		:'__LU_BLOB_CLOSE_SEND':
			blob_close;
			buff := NULL;
		:'__LU_BLOB_CLOSE_RECEIVE':
			blob_close(pBLOB);
			buff := NULL;
		:'__LU_BLOB_SEND_BLOCK':
			blob_send_next_block(buff);
		:'__LU_BLOB_RECEIVE_BLOCK':
			blob_receive_next_block(buff);
	end;
end;
/**
 * Обработка сообщения передачи данных
 *
 * @param info	Код параметра валидации. При вызове нужно передавать P_INFO
 * @param buff	Параметр или переменная операции, использующаяся для передачи блока данных (п. 1 в описании использования)
 * @param pCLOB	Переменная типа CLOB откуда будет считываться или сохраняться данные
 */
public procedure lob_validate(
	info string
	, buff in out nocopy string
	, pCLOB in out nocopy CLOB
	)
is
begin
	case info of
		:'__LU_CLOB_INIT_SEND':
			clob_init(pCLOB);
			gLOB_offs := 1;
			buff := nvl(to_char(dbms_lob.getlength(pCLOB)), '0');
		:'__LU_CLOB_INIT_RECEIVE':
			clob_init;
			buff := NULL;
		:'__LU_CLOB_CLOSE_SEND':
			clob_close;
			buff := NULL;
		:'__LU_CLOB_CLOSE_RECEIVE':
			clob_close(pCLOB);
			buff := NULL;
		:'__LU_CLOB_SEND_BLOCK':
			clob_send_next_block(buff);
		:'__LU_CLOB_RECEIVE_BLOCK':
			clob_receive_next_block(buff);
	end;
end;

-- *** Функции проверки объема передачи данных ***

type T_FILE_NAME_INDEX_TABLE is table of string(1) index by string(512);

/**
 * Дополняет переданный список файлов по пути и маске файла
 *
 * @param path	Каталог поиска (относительно корня FIO)
 * @param file_mask	Маска файлов добавляемых в список (*.* и * - разные)
 * @param file_list	Дополняемый список
 * @param distinct_fn	Признак контроля дублей в списке: true - файлы не дублируются при добавлении в список
 */
public procedure append_file_list(
	path string
	, file_mask string
	, file_list in out nocopy T_FILE_LIST
	, distinct_fn boolean := false
	)
is
	hd integer;
	fp string(512) := nvl(rtrim(path, '/'), '.');
	nt T_FILE_NAME_INDEX_TABLE;
	idx integer;
	fn string(512);
	fa string;
	fu string;
	fg string;
	fm string;
	fs number;
	res integer;
begin
	hd := stdio.opendir(fp, file_mask, 1);
	if hd <= 0 then
		return;
	end if;

	if distinct_fn then
		idx := file_list.first;
		while idx is not NULL loop
			nt(file_list(idx)) := '1';
			idx := file_list.next(idx);
		end loop;
	end if;
	
	loop
		res := stdio.read_dir(hd, fn, fa, fu, fg, fm, fs);
		exit when res <= 0;

		idx := nvl(file_list.last, 0) + 1;
		fn := fp || '/' || fn;
		if distinct_fn then
			if not nt.exists(fn) then
				file_list(idx) := fn;
			end if;
		else
			file_list(idx) := fn;
		end if;
	end loop;

	res := stdio.closedir(hd);
end;

/**
 * Формирует список файлов по пути и маске файла
 *
 * @param path	Каталог поиска (относительно корня FIO)
 * @param file_mask	Маска файлов добавляемых в список (*.* и * - разные)
 * @return	Возвращает сформированный список файлов
 */
public function get_file_list(
	path string
	, file_mask string
) return T_FILE_LIST is
	fl T_FILE_LIST;
begin
	append_file_list(path, file_mask, fl, false);
	return fl;
end;

/**
 * Возвращает общий размер файлов по списку
 *
 * @param file_list	Список файлов, размер которых определяется
 * @return	Возвращает общий размер файлов по списку
 */
public function get_file_list_size(file_list T_FILE_LIST) return number is
	idx integer;
	f_attrs string;
	f_uowner string;
	f_gowner string;
	f_mdate string;
	f_fsize number;
	res integer;
	sz number := 0;
begin
	idx := file_list.first;
	while idx is not NULL loop
		res := stdio.finfo(file_list(idx), f_attrs, f_uowner, f_gowner, f_mdate, f_fsize);
		if res = 0 then
			sz := sz + f_fsize;
		else
			pragma error('Ошибка при определения размера файла ' || file_list(idx) || ' (' || res || ')!');
		end if;
		idx := file_list.next(idx);
	end loop;
	return sz;
end;

/**
 * Проверяет размер передаваемых данных
 *
 * @param sz	Размер передаваемых данных в байтах
 * @return	Возвращает результат сравнения размера и ограничения: false - превышает ограничение, true - не превышает ограничение или ограничения не установлено
 */
public function check_size(sz number) return boolean is
begin
	if gLOB_UTILS_size_limit is NULL then
		return true;
	end if;
	return sz <= gLOB_UTILS_size_limit;
end;

/**
 * Проверяет размер передаваемого файла
 *
 * @param filepath	Путь к файлу
 * @param filename	Имя файла
 * @return	Возвращает результат сравнения размера файла и ограничения: false - превышает ограничение, true - не превышает ограничение или ограничения не установлено
 */
public function check_file_size(filepath string, filename string) return boolean is
	fl T_FILE_LIST;
begin
	if gLOB_UTILS_size_limit is NULL then
		return true;
	end if;
	fl(1) := nvl(rtrim(filepath, '/'), '.') || '/' || filename;
	return check_size(get_file_list_size(fl));
end;

/**
 * Проверяет размер передаваемого каталога
 *
 * @param dirpath	Каталог
 * @return	Возвращает результат сравнения размера файлов каталога и ограничения: false - превышает ограничение, true - не превышает ограничение или ограничения не установлено
 */
public function check_dir_size(dirpath string) return boolean is
begin
	if gLOB_UTILS_size_limit is NULL then
		return true;
	end if;
	return check_file_list_size(get_file_list(dirpath, '*.*'));
end;

/**
 * Проверяет размер передаваемого списка файлов
 *
 * @param file_list	Список файлов, размер которых проверяется
 * @return	Возвращает результат сравнения размера файлов списка и ограничения: false - превышает ограничение, true - не превышает ограничение или ограничения не установлено
 */
public function check_file_list_size(file_list T_FILE_LIST) return boolean is
begin
	if gLOB_UTILS_size_limit is NULL then
		return true;
	end if;
	return check_size(get_file_list_size(file_list));
end;

-- *********************
-- *** Общие функции ***
-- *********************

/**
 * Основные кодировки, используемые для кириллицы
 */
public C_CHARSET_WIN &STR_CONST('CL8MSWIN1251');
public C_CHARSET_DOS &STR_CONST('RU8PC866');
public C_CHARSET_UNIX &STR_CONST('CL8ISO8859P5');
public C_CHARSET_KOI8 &STR_CONST('CL8KOI8R');
public C_CHARSET_UTF8 &STR_CONST('AL32UTF8');
public C_CHARSET_UTF16 &STR_CONST('AL16UTF16');

/**
 * Проверка указателя BLOB. Функция используется для проверки необходимости освобождения созданного CLOB (freetemporary)
 *
 * @param b	Проверяемый BLOB-указатель
 * @return	Если BLOB создан и не пустой, то возвращает true
 */
public function check_lob_locator(b BLOB) return boolean is
	sz number;
begin
	sz := dbms_lob.getlength(b);
	return (sz is not NULL);
exception when others all then
	if SQLCODE = -22275 then -- Invalid LOB locator
		return false;
	end if;
	raise;
end;
/**
 * Проверка указателя CLOB. Функция используется для проверки необходимости освобождения созданного CLOB (freetemporary)
 *
 * @param c	Проверяемый CLOB-указатель
 * @return	Если CLOB создан и не пустой, то возвращает true
 */
public function check_lob_locator(c CLOB) return boolean is
	sz number;
begin
	sz := dbms_lob.getlength(c);
	return (sz is not NULL);
exception when others all then
	if SQLCODE = -22275 then -- Invalid LOB locator
		return false;
	end if;
	raise;
end;

/**
 * Очистка BLOB. Удаляет все данные из BLOB'а, переводит указатель в начало, устанавливает размер 0
 *
 * @param b	Очищаемый BLOB
 */
public procedure clear_lob(b in out nocopy BLOB) is
begin
	dbms_lob.trim(b, 0);
end;
/**
 * Очистка CLOB. Удаляет все данные из CLOB'а, переводит указатель в начало, устанавливает размер 0
 *
 * @param c	Очищаемый CLOB
 */
public procedure clear_lob(c in out nocopy CLOB) is
begin
	dbms_lob.trim(c, 0);
end;

/**
 * Конкатенация массива (таблицы) строк в один CLOB
 *
 * @param str_tab	Таблица строк
 * @param delim	Необязательный разделитель
 * @return	CLOB с результатом конкатенации
 */
public function concat_clob(
	str_tab rtl.STRING_TABLE
	, delim string := NULL
)
return CLOB is
	c CLOB;
	buff string(32767) := NULL;
	idx integer;
	procedure flush_ is
	begin
		if buff is not NULL then
			dbms_lob.writeappend(c, length(buff), buff);
			buff := NULL;
		end if;
	end;
	procedure push_(s_ string) is
	begin
		if s_ is not NULL then
			if coalesce(length(buff), 0) + length(s_) > buff%size then
				flush_;
			end if;
			buff := buff || s_;
		end if;
	end;
begin
	dbms_lob.createtemporary(c, true);
	idx := str_tab.first;
	while idx is not NULL loop
		push_(str_tab(idx));
		idx := str_tab.next(idx);
		if delim is not NULL and idx is not NULL then
			push_(delim);
		end if;
	end loop;
	flush_;
	return c;
end;
/**
 * Конкатенация набора строк (до 10) в один CLOB
 *
 * @param s1	Строка 1
 * @param s2	Строка 2
 * @param s3	Строка 3
 * @param s4	Строка 4
 * @param s5	Строка 5
 * @param s6	Строка 6
 * @param s7	Строка 7
 * @param s8	Строка 8
 * @param s9	Строка 9
 * @param s10	Строка 10
 * @return	CLOB с результатом конкатенации
 */
public function concat_clob(
	s1 string
	, s2 string
	, s3 string := NULL
	, s4 string := NULL
	, s5 string := NULL
	, s6 string := NULL
	, s7 string := NULL
	, s8 string := NULL
	, s9 string := NULL
	, s10 string := NULL
)
return CLOB is
	str_tab rtl.STRING_TABLE;
begin
	&MAKE_LIST('str_tab(#):=s#;', 10, '')
	return concat_clob(str_tab);
end;
/**
 * Конкатенация нескольких CLOB (до 10) в один CLOB
 *
 * @param c1	Часть 1
 * @param c2	Часть 2
 * @param c3	Часть 3
 * @param c4	Часть 4
 * @param c5	Часть 5
 * @param c6	Часть 6
 * @param c7	Часть 7
 * @param c8	Часть 8
 * @param c9	Часть 9
 * @param c10	Часть 10
 * @return	CLOB с результатом конкатенации
 */
public function concat_clob(
	c1 CLOB
	, c2 CLOB
	, c3 CLOB := NULL
	, c4 CLOB := NULL
	, c5 CLOB := NULL
	, c6 CLOB := NULL
	, c7 CLOB := NULL
	, c8 CLOB := NULL
	, c9 CLOB := NULL
	, c10 CLOB := NULL
)
return CLOB is
	c CLOB;
	l number;
	pragma macro(WRITE_IF, 'if [1] is not NULL then l:= dbms_lob.getlength([1]); if l > 0 then dbms_lob.append(c, [1]); end if; end if', substitute);
begin
	dbms_lob.createtemporary(c, true);
	&MAKE_LIST('&WRITE_IF(c#);', 10, '')
	return c;
end;
/**
 * Конкатенация CLOB и набора строк (до 10) в один CLOB
 *
 * @param c1	Исходный CLOB
 * @param s1	Строка 1
 * @param s2	Строка 2
 * @param s3	Строка 3
 * @param s4	Строка 4
 * @param s5	Строка 5
 * @param s6	Строка 6
 * @param s7	Строка 7
 * @param s8	Строка 8
 * @param s9	Строка 9
 * @param s10	Строка 10
 * @return	CLOB с результатом конкатенации
 */
public function concat_clob(
	c1 CLOB
	, s1 string
	, s2 string := NULL
	, s3 string := NULL
	, s4 string := NULL
	, s5 string := NULL
	, s6 string := NULL
	, s7 string := NULL
	, s8 string := NULL
	, s9 string := NULL
	, s10 string := NULL
)
return CLOB is
begin
	return concat_clob(c1, concat_clob(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10));
end;

-- *** Преобразования ***

/**
 * Конвертирует CLOB из кодировки srcset в кодировку destset. Если кодировка NULL, то используется кодировка БД
 *
 * @param pCLOB	CLOB для конвертации
 * @param destset	Целевая кодировка. Если передан NULL, то используется кодировка БД. Пример: 'CL8MSWIN1251', 'UTF8'
 * @param srcset	Исходная кодировка. Если передан NULL, то используется кодировка БД. Пример: 'CL8ISO8859P5'
 */
public procedure clob_convert(
	pCLOB in out nocopy CLOB
	, destset string
	, srcset string := NULL
	)
is
begin
	if dbms_lob.getlength(pCLOB) = 0 then
		return;
	end if;

	if destset is NULL or srcset is NULL then
		if gDB_NLS is NULL then	
			gDB_NLS := get_db_nls;
		end if;
		destset := nvl(destset, gDB_NLS);
		srcset := nvl(srcset, gDB_NLS);
	end if;
	
	pCLOB := convert(pCLOB, destset, srcset);
end;
/**
 * Конвертирует BLOB из кодировки srcset в кодировку destset. Если кодировка NULL, то используется кодировка БД
 *
 * @param pBLOB	BLOB для конвертации
 * @param destset	Целевая кодировка. Если передан NULL, то используется кодировка БД. Пример: 'CL8MSWIN1251', 'UTF8'
 * @param srcset	Исходная кодировка. Если передан NULL, то используется кодировка БД. Пример: 'CL8ISO8859P5'
 */
public procedure blob_convert(
	pBLOB in out nocopy BLOB
	, destset string
	, srcset string := NULL
	)
is
	ncl NCLOB;
	d_csid number := NULL;
	s_csid number := NULL;
	dest_offs number;
	src_offs number;
	warn number;
	lang_ctx number := dbms_lob.default_lang_ctx;
begin
	-- кодировки
	d_csid := get_csid(coalesce(destset, get_db_nls));
	s_csid := get_csid(coalesce(srcset, get_db_nls));
	if d_csid = s_csid then -- кодировки совпадают - преобразование не требуется
		return;
	end if;

	-- конвертация
	dbms_lob.createtemporary(ncl, true); -- через Unicode-CLOB

	src_offs = dest_offs := 1;
	dbms_lob.convertToClob(ncl, pBLOB, dbms_lob.lobmaxsize, dest_offs, src_offs, s_csid, lang_ctx, warn); -- конвертация в Unicode

	clear_lob(pBLOB);
	src_offs = dest_offs := 1;
	dbms_lob.convertToBlob(pBLOB, ncl, dbms_lob.lobmaxsize, dest_offs, src_offs, d_csid, lang_ctx, warn); -- конвертация из Unicode в целевую кодировку

	dbms_lob.freetemporary(ncl);
end;

-- Служебная функция для определения BOM
function get_BOM_(head raw) return string is
	h string;
	function test_signatures(sig string) return boolean is
		l_ number;
		sig_ string(2000);
		s_ string;
	begin
		sig_ := sig;
		while sig_ is not NULL loop
			s_ := [STR].split_by(sig_, '|');
			l_ := length(s_);
			if substr(h, 1, l_) = s_ then
				h := substr(h, 1, l_);
				return true;
			end if;
		end loop;
		return false;
	end;
begin
	if head is NULL then
		return NULL;
	end if;
	h := upper(rawtohex(head));
	if test_signatures('EFBBBF') then -- UTF-8
		return h;
	elsif test_signatures('FEFF|FFFE') then -- UTF-16
		return h;
	elsif test_signatures('0000FEFF|FFFE0000') then -- UTF-32
		return h;
	elsif test_signatures('2B2F7638|2B2F7639|2B2F762B|2B2F762F') then -- UTF-7
		return h;
	elsif test_signatures('F7644C') then -- UTF-1
		return h;
	elsif test_signatures('DD736673') then -- UTF-EBCDIC
		return h;
	elsif test_signatures('0EFEFF') then -- SCSU
		return h;
	elsif test_signatures('FBEE28') then -- BOCU-1
		return h;
	elsif test_signatures('84319533') then -- GB-18030
		return h;
	end if;
	return NULL;
end;
/**
 * Находит и возвращает BOM-сигнатуру в начале CLOB, если она есть
 *
 * @param p_CLOB	обрабатываемый CLOB
 * @param p_cut_off	признак удаления BOM
 * @return	BOM-сигнатура в виде hex-строки
 */
public function get_BOM(
	p_CLOB in out nocopy CLOB
	, p_cut_off boolean := true
	)
return string is
	r raw(4);
	bom string(8);
	offs number;
	l number;
begin
	r := utl_raw.cast_to_raw(dbms_lob.substr(p_CLOB, 4, 1));
	bom := get_BOM_(r);
	if bom is not NULL and p_cut_off then
		offs := trunc(length(bom) / 2);
		l := dbms_lob.getlength(p_CLOB) - offs;
		dbms_lob.copy(p_CLOB, p_CLOB, l, 1, offs + 1);
		dbms_lob.trim(p_CLOB, l);
	end if;
	return bom;
end;
/**
 * Находит и отрезает BOM-сигнатуру в начале BLOB, если она есть
 *
 * @param p_BLOB	обрабатываемый BLOB
 * @param p_cut_off	признак удаления BOM
 * @return	BOM-сигнатура в виде hex-строки
 */
public function get_BOM(
	p_BLOB in out nocopy BLOB
	, p_cut_off boolean := true
	)
return string is
	r raw(4);
	bom string(8);
	offs number;
	l number;
begin
	r := dbms_lob.substr(p_BLOB, 4, 1);
	bom := get_BOM_(r);
	if bom is not NULL and p_cut_off then
		offs := trunc(length(bom) / 2);
		l := dbms_lob.getlength(p_BLOB) - offs;
		dbms_lob.copy(p_BLOB, p_BLOB, l, 1, offs + 1);
		dbms_lob.trim(p_BLOB, l);
	end if;
	return bom;
end;

/**
 * Определение кодировки по BOM-сигнатуре (если возможно)
 *
 * @param p_bom	BOM-сигнатура в виде hex-строки
 * @return	Строка с кодировкой. Пример: 'CL8MSWIN1251', 'UTF8'
 */
public function BOM_to_charset(p_bom string) return string is
begin
	case p_bom of
		:'EFBBBF':
			return C_CHARSET_UTF8; -- UTF-8
		:'FEFF':
			return C_CHARSET_UTF16; -- UTF-16 BE
		:'FFFE':
			return 'AL16UTF16LE'; -- UTF-16 LE
		:'0000FEFF':
			return 'AL32UTF32'; -- UTF-32 BE
		:'FFFE0000':
			return ''; -- UTF-32 LE
		:'2B2F7638', '2B2F7639', '2B2F762B', '2B2F762F':
			return ''; -- UTF-7
		:'F7644C':
			return ''; -- UTF-1
		:'DD736673':
			return 'UTFE'; -- UTF-EBCDIC
		:'0EFEFF':
			return ''; -- SCSU
		:'FBEE28':
			return ''; -- BOCU-1
		:'84319533':
			return 'ZHS32GB18030'; -- GB-18030
	end;
	return NULL;
end;

/**
 * Находит и возвращает кодировку из xml-декларации в начале xml-документа
 *
 * @param xml	Строка с xml-документом или его началом, содержащая декларацию
 * @return	Строка с кодировкой xml. Пример: 'windows-1251', 'UTF-8'
 */
public function get_xml_encoding(xml string) return string is
	s string(500);
begin
	s := regexp_substr(xml, '<\?xml\s*[^?]*(\?>)?', 1, 1, 'i');
	if s is not NULL then
		s := regexp_substr(s, 'encoding="([^"]+)"', 1, 1, 'i');
		if s is not NULL then
			s := regexp_replace(s, 'encoding="([^"]+)"', '\1', 1, 1, 'i');
			return s;
		end if;
	end if;
	return NULL;
end;
/**
 * Находит и возвращает кодировку из xml-декларации в начале xml-документа
 *
 * @param p_CLOB	xml-документ в CLOB
 * @return	Строка с кодировкой xml. Пример: 'windows-1251', 'UTF-8'
 */
public function get_xml_encoding(p_CLOB CLOB) return string is
begin
	return get_xml_encoding(dbms_lob.substr(p_CLOB, 500, 1));
end;
/**
 * Находит и возвращает кодировку из xml-декларации в начале xml-документа
 *
 * @param p_BLOB	xml-документ в BLOB
 * @return	Строка с кодировкой xml. Пример: 'windows-1251', 'UTF-8'
 */
public function get_xml_encoding(p_BLOB BLOB) return string is
	r raw(500);
	s string(500);
begin
	r := dbms_lob.substr(p_BLOB, 500, 1);
	s := utl_raw.cast_to_varchar2(r);
	return get_xml_encoding(s);
end;

/**
 * Преобразование идентификаторов кодировок: из формата oracle в xml
 *
 * @param 	p_enc	Строка с кодировкой xml. Пример: 'windows-1251', 'UTF-8'
 * @return			Строка с кодировкой. Пример: 'CL8MSWIN1251', 'UTF8'
 */
public function xml_encoding_to_charset(p_enc string) return string is
begin
	case lower(p_enc) of
		:'iso-8859-5': -- UNIX
			return C_CHARSET_UNIX;
		:'windows-1251': -- Windows
			return C_CHARSET_WIN;
		:'koi8-r': -- KOI8-R
			return C_CHARSET_KOI8;
		:'cp866': --  DOS
			return C_CHARSET_DOS;
		:'utf-8': -- UTF-8
			return C_CHARSET_UTF8;
		:'utf-16': -- UTF-16
			return C_CHARSET_UTF16;
	end;
	return utl_i18n.map_charset(charset == p_enc, flag == utl_i18n.IANA_TO_ORACLE);
end;
/**
 * DEPRECATED
 * ВНИМАНИЕ! Использование функции запрещено. Теперь нужно использовать charset_to_xml_encoding.
 * Преобразование идентификаторов кодировок: из формата xml в oracle
 *
 * @param 	p_cs	Строка с кодировкой. Пример: 'CL8MSWIN1251', 'UTF8'
 * @return			Строка с кодировкой xml. Пример: 'windows-1251', 'UTF-8'
 */
public function carset_to_xml_encoding(p_cs string) return string is
begin
	return charset_to_xml_encoding(p_cs);
end;
/**
 * Преобразование идентификаторов кодировок: из формата xml в oracle
 *
 * @param 	p_cs	Строка с кодировкой. Пример: 'CL8MSWIN1251', 'UTF8'
 * @return			Строка с кодировкой xml. Пример: 'windows-1251', 'UTF-8'
 */
public function charset_to_xml_encoding(p_cs string) return string is
begin
	case p_cs of
		:'CL8ISO8859P5': -- UNIX
			return 'iso-8859-5';
		:'CL8MSWIN1251': -- Windows
			return 'windows-1251';
		:'CL8KOI8R': -- KOI8-R
			return 'koi8-r';
		:'RU8PC866': --  DOS
			return 'cp866';
		:'UTF8', 'AL32UTF8': -- UTF-8
			return 'utf-8';
		:'UTF16': -- UTF-16
			return 'utf-16';
	end;
	return utl_i18n.map_charset(charset == p_cs, flag == utl_i18n.ORACLE_TO_IANA);
end;

/**
 * Определение кодировки БД
 *
 * @return	Строка с кодировкой БД
 */
public function get_db_nls return string is
	chset string;
begin
	select x(x.value) in nls_database_parameters%rowtype where x.parameter = 'NLS_CHARACTERSET' into chset;
	return chset;
end;

pragma macro(CHARSET_ID, 'begin select nvl(to_char(nls_charset_id([1])), ''NULL'') into [0] from dual; end;', process);
/**
 * Определяет числовой идентификатор кодировки
 *
 * @param charset	Строка с кодировкой. Пример: 'CL8MSWIN1251', 'UTF8'
 * @return	Числовой идентификатор переданной кодировки
 */
public function get_csid(charset string) return number is
	csid number;
begin
	case charset of
		:'CL8ISO8859P5': -- UNIX
			csid := &CHARSET_ID('CL8ISO8859P5');
		:'CL8MSWIN1251': -- Windows
			csid := &CHARSET_ID('CL8MSWIN1251');
		:'CL8KOI8R': -- KOI8-R
			csid := &CHARSET_ID('CL8KOI8R');
		:'RU8PC866': --  DOS
			csid := &CHARSET_ID('RU8PC866');
		:'UTF8': -- UTF-8
			csid := &CHARSET_ID('UTF8');
		:'AL32UTF8': -- UTF-8 (5.0)
			csid := &CHARSET_ID('AL32UTF8');
		:'AL16UTF16': -- UTF-16
			csid := &CHARSET_ID('AL16UTF16');
		:'AL32UTF32': -- UTF-32
			csid := &CHARSET_ID('AL32UTF32');
	else
		execute immediate 'select nls_charset_id(:charset) from dual' into csid using charset;
	end;
	return csid;
end;

/**
 * Преобразует CLOB в BLOB со сменой кодировки, если указана
 *
 * @param destBLOB	BLOB-приемник. Не должен быть пустым, создается перед вызовом. Будет полностью перезаписан.
 * @param srcCLOB	CLOB-источник
 * @param charset	кодировка приемника, если не указана, то без изменения кодировки
 */
public procedure clob2blob(
	destBLOB in out nocopy BLOB
	, srcCLOB CLOB
	, charset string := NULL
	)
is
	dest_offs number := 1;
	src_offs number := 1;
	warn number;
	lang_ctx number := dbms_lob.default_lang_ctx;
	csid number := NULL;
begin
	if charset is not NULL then
		csid := get_csid(charset);
	end if;
	csid := nvl(csid, dbms_lob.default_csid);
	clear_lob(destBLOB);
	dbms_lob.convertToBlob(destBLOB, srcCLOB, dbms_lob.lobmaxsize, dest_offs, src_offs, csid, lang_ctx, warn);
end;
/**
 * Преобразует BLOB в CLOB со сменой кодировки, если указана
 *
 * @param destCLOB	CLOB-приемник. Не должен быть пустым, создается перед вызовом. Будет полностью перезаписан.
 * @param srcBLOB	BLOB-источник
 * @param charset	кодировка источника, если не указана, то без изменения кодировки
 */
public procedure blob2clob(
	destCLOB in out nocopy CLOB
	, srcBLOB BLOB
	, charset string := NULL
	)
is
	dest_offs number := 1;
	src_offs number := 1;
	warn number;
	lang_ctx number := dbms_lob.default_lang_ctx;
	csid number := NULL;
begin
	if charset is not NULL then
		csid := get_csid(charset);
	end if;
	csid := nvl(csid, dbms_lob.default_csid);
	clear_lob(destCLOB);
	dbms_lob.convertToClob(destCLOB, srcBLOB, dbms_lob.lobmaxsize, dest_offs, src_offs, csid, lang_ctx, warn);
end;

/**
 * Преобразует данные BLOB в символьный вид в формате base64
 *
 * @param destB64CLOB	CLOB-приемник данных в формате base64. Не должен быть пустым, создается перед вызовом. Будет полностью перезаписан.
 * @param srcBLOB	BLOB-источник
 */
public procedure blob2base64(
	destB64CLOB in out nocopy CLOB
	, srcBLOB BLOB
	)
is
	amount number;
	len number;
	offset number := 1;
	buffer raw(32767);
	text string(32767);
	raw_NL raw(3) := utl_raw.cast_to_raw('0' || NL$);
	raw_ raw(1) := utl_raw.cast_to_raw('0');
begin
	dbms_lob.trim(destB64CLOB, 0);
	len := dbms_lob.getlength(srcBLOB);
	while offset <= len loop
		amount := 21000;
		dbms_lob.read(srcBLOB, amount, offset, buffer);
		text := utl_raw.cast_to_varchar2(utl_raw.translate(utl_encode.base64_encode(buffer), raw_NL, raw_));
		dbms_lob.writeappend(destB64CLOB, length(text), text);
		offset := offset + amount;
	end loop;
end;
/**
 * Преобразует данные BLOB в символьный вид в формате base64
 *
 * @param srcBLOB	BLOB-источник
 * @return	Текст с данными в формате base64
 */
public function blob2base64(srcBLOB BLOB) return CLOB is
	c CLOB := NULL;
begin
	if srcBLOB is not NULL then
		dbms_lob.createtemporary(c, true);
		blob2base64(c, srcBLOB);
	end if;
	return c;
end;

/**
 * Символьные данные в формате base64 в данные BLOB
 *
 * @param destBLOB	BLOB-приемник данных. Не должен быть пустым, создается перед вызовом. Будет полностью перезаписан.
 * @param srcB64CLOB	Текст с данными в формате base64
 */
public procedure base642blob(
	destBLOB in out nocopy BLOB
	, srcB64CLOB CLOB
	)
is
	len number;
	amount number;
	text string(32767);
	buffer raw(32767);
	offset number := 1;
begin
	dbms_lob.trim(destBLOB, 0);
	len := dbms_lob.getlength(srcB64CLOB);
	while offset <= len loop
		amount := 32000;
		dbms_lob.read(srcB64CLOB, amount, offset, text);
		buffer := utl_encode.base64_decode(utl_raw.cast_to_raw(text));
		dbms_lob.writeappend(destBLOB, utl_raw.length(buffer), buffer);
		offset := offset + amount;
	end loop;
end;
/**
 * Преобразует данные BLOB в символьный вид в формате base64
 *
 * @param srcB64CLOB	Текст с данными в формате base64
 * @return	Раскодированные данные
 */
public function base642blob(srcB64CLOB CLOB) return BLOB is
	b BLOB := NULL;
begin
	if srcB64CLOB is not NULL then
		dbms_lob.createtemporary(b, true);
		base642blob(b, srcB64CLOB);
	end if;
	return b;
end;


-- *** Работа с файлами ***

procedure check_fio_error(res integer) is
begin
	if res < 0 then
		pragma error(stdio.error_message(res));
	end if;
end;

function get_file_name(p_path string, p_name string) return string is
begin
	if substr(p_path, -1, 1) = l_slash then
		return substr(p_path, 1, length(p_path) - 1) || l_slash || p_name;
	end if;
	return p_path || l_slash || p_name;
end;

/**
 * Чтение содержимого файла в переданный BLOB
 *
 * @param p_blob	BLOB-приемник. Не должен быть пустым, создается перед вызовом. Будет полностью перезаписан.
 * @param p_filedir	Путь к файлу
 * @param p_filename	Имя файла
 */
public procedure file2blob(
	p_blob in out nocopy BLOB
	, p_filedir varchar2
	, p_filename varchar2
	)
is
	v_fd 	integer;
	buffer 	raw(32000);
	amount 	number := 32000;
	offset 	number := 1;
	cnt 	number;
begin
	clear_lob(p_blob);

	v_fd := stdio.f_open(get_file_name(p_filedir, p_filename), 'r');
	check_fio_error(v_fd);
	
	begin
		loop
			cnt := stdio.f_read(v_fd, buffer, amount);
		exit when cnt <= 0;
			if buffer is not null then
				dbms_lob.write(p_blob, cnt, offset, buffer);
				offset := offset + cnt;
			end if;
		end loop;
	exception when others then
		null;
	end;
	cnt := stdio.f_close(v_fd);
end;
/**
 * Чтение содержимого файла и возврат в виде BLOB
 *
 * @param p_filedir	Путь к файлу
 * @param p_filename	Имя файла
 * @return	BLOB с содержимым файла. Создается в функции и должен быть освобожден (freetemporary) по окончании использования.
 */
public function file2blob(
	p_filedir varchar2
	, p_filename varchar2
)
return BLOB is
	v_blob 	blob;
begin
	dbms_lob.createtemporary(v_blob, true);
	
	file2blob(v_blob, p_filedir, p_filename);

	return v_blob;
end;

/**
 * Запись в файл содержимого BLOB. Перезаписывает или создает файл и записывает в него содержимое BLOB
 *
 * @param p_blob	BLOB-источник
 * @param p_filedir	Путь к файлу. Должен существовать
 * @param p_filename	Имя файла
 */
public procedure blob2file(
	p_blob BLOB
	, p_filedir varchar2
	, p_filename varchar2
	)
is
	v_fd 	integer;
	amount 	number := 32000;
	offset 	number := 1;
	buffer 	raw(32000);
	res integer;
begin
	v_fd := stdio.f_open(get_file_name(p_filedir, p_filename), 'w');
	check_fio_error(v_fd);

	loop
		begin
			dbms_lob.read(p_blob, amount, offset, buffer);
		exception when standard.NO_DATA_FOUND then
			exit;
		end;
		res := stdio.f_write(v_fd, buffer);
		check_fio_error(res);
		offset := offset + amount;
	end loop;
	res := stdio.f_close(v_fd);
	check_fio_error(res);
end;

/**
 * Чтение содержимого файла в CLOB
 *
 * @param p_clob	CLOB-приемник. Не должен быть пустым, создается перед вызовом. Будет полностью перезаписан.
 * @param p_filedir	Путь к файлу
 * @param p_filename	Имя файла
 */
public procedure file2clob(
	p_clob in out nocopy CLOB
	, p_filedir varchar2
	, p_filename varchar2
	)
is
	v_fd 	integer;
	buffer 	raw(32000);
	str 	string(32000);
	amount 	number := 32000;
	offset 	number := 1;
	cnt 	number;
begin
	clear_lob(p_clob);

	v_fd := stdio.f_open(get_file_name(p_filedir, p_filename), 'r');
	check_fio_error(v_fd);
	
	begin
		loop
			cnt := stdio.f_read(v_fd, buffer, amount);
			str := utl_raw.cast_to_varchar2(buffer);
		exit when cnt <= 0;
			if str is not null then
				dbms_lob.write(p_clob, cnt, offset, str);
				offset := offset + cnt;
			end if;
		end loop;
	exception when others then
		null;
	end;
	cnt := stdio.f_close(v_fd);
end;
/**
 * Чтение содержимого файла и возврат в виде CLOB
 *
 * @param p_filedir	Путь к файлу
 * @param p_filename	Имя файла
 * @return	CLOB с содержимым файла. Создается в функции и должен быть освобожден (freetemporary) по окончании использования.
 */
public function file2clob(
	p_filedir varchar2
	, p_filename varchar2
	)
return CLOB is
	v_clob 	clob;
begin
	dbms_lob.createtemporary(v_clob, true);

	file2clob(v_clob, p_filedir, p_filename);

	return v_clob;
end;

/**
 * Запись в файл содержимого CLOB. Перезаписывает или создает файл и записывает в него содержимое CLOB
 *
 * @param p_clob	CLOB-источник
 * @param p_filedir	Путь к файлу. Должен существовать
 * @param p_filename	Имя файла
 */
public procedure clob2file(
	p_clob CLOB
	, p_filedir varchar2
	, p_filename varchar2
	)
is
	v_fd 	integer;
	amount 	number := 32000;
	offset 	number := 1;
	buffer 	raw(32000);
	str 	string(32000);
	res integer;
begin
	v_fd := stdio.f_open(get_file_name(p_filedir, p_filename), 'w');
	check_fio_error(v_fd);

	loop
		begin
			dbms_lob.read(p_clob, amount, offset, str);
		exception when standard.NO_DATA_FOUND then
			exit;
		end;
		buffer := utl_raw.cast_to_raw(str);
		res := stdio.f_write(v_fd, buffer);
		check_fio_error(res);
		offset := offset + amount;
	end loop;
	res := stdio.f_close(v_fd);
	check_fio_error(res);
end;

/**
 * Пара для поиска-замены в BLOB
 *
 * @param find Искомая последовательность
 * @param repl Последовательность для замены. NULL для удаления найденных вхождений find
 */
public type T_BLOB_REPLACE_PAIR is record (
	find raw(2000),
	repl raw(2000)
);
/**
 * Таблица пар для поиска-замены
 */
public type T_BLOB_REPLACE_TAB is table of T_BLOB_REPLACE_PAIR;

/**
 * Добавление в таблицу пар поиск-замена очередной пары
 *
 * @param replace_tab Таблица пар для заполнения
 * @param find Искомая последовательность. Не должна превышать 2000 байт
 * @param repl Последовательность для замены. Не должна превышать 2000 байт. Для удаления найденных вхождений find установить значение NULL.
 */
public procedure push_replace_pair(replace_tab in out nocopy T_BLOB_REPLACE_TAB, find raw, repl raw) is
	pair T_BLOB_REPLACE_PAIR;
begin
	pair.find := find;
	pair.repl := repl;
	replace_tab(nvl(replace_tab.last, 0) + 1) := pair;
end;

--
type T_PAIR_REC is record (
	find raw(2000),
	repl raw(2000),
	find_len number,
	repl_len number
);
type T_PAIR_TAB is table of T_PAIR_REC;
type T_FOUND_REC is record (
	offs number,
	pair_idx integer
);
type T_FOUND_TAB is table of T_FOUND_REC;

function compare_found(a T_FOUND_REC, b T_FOUND_REC) return integer is
begin
	return case when a.offs > b.offs then 1 when a.offs < b.offs then -1 else 0 end;
end;

pragma include(::[RUNTIME].[MACRO_LIB_TAB]);
&QUICKSORT_PROC_2(sort_found, T_FOUND_REC, T_FOUND_TAB, compare_found);

/**
 * Поиск и замена в BLOB. Выполняется поиск и замена сразу нескольких пар последовательностей
 *
 * @param b BLOB, в котором выполняется поиск
 * @param replace_tab Таблица пар последовательностей для поиска-замены
 * @return Результат замен в BLOB. Новый BLOB с заменами или исходный, если ничего не было найдено
 */
public function blob_replace(b BLOB, replace_tab T_BLOB_REPLACE_TAB) return BLOB is
	res BLOB;
	
	pairs_tab T_PAIR_TAB;
	found_tab T_FOUND_TAB;
	
	procedure push_pair(pair_ T_BLOB_REPLACE_PAIR) is
		rec T_PAIR_REC;
	begin
		if pair_.find is not NULL then
			rec.find := pair_.find;
			rec.repl := pair_.repl;
			rec.find_len := utl_raw.length(pair_.find);
			rec.repl_len := case when pair_.repl is NULL then 0 else utl_raw.length(pair_.repl) end;
			pairs_tab(pairs_tab.count + 1) := rec;
		end if;
	end;
	
	C_QUOT raw(6) := utl_raw.cast_to_raw('&quot;');
	C_MINUS raw(1) := utl_raw.cast_to_raw('-');
	
	frec T_FOUND_REC;
	pair T_PAIR_REC;
	offs_dst number := 1;
	offs_src number := 1;
	len number;
	idx integer;
begin
	-- подготовка
	idx := replace_tab.first;
	while idx is not NULL loop
		push_pair(replace_tab(idx));
		idx := replace_tab.next(idx);
	end loop;
	-- поиск
	for i in 1..pairs_tab.count loop
		frec.pair_idx := i;
		frec.offs := 1;
		loop
			frec.offs := dbms_lob.instr(b, pairs_tab(i).find, frec.offs);
			exit when frec.offs = 0;
			found_tab(found_tab.count + 1) := frec;
			frec.offs := frec.offs + pairs_tab(i).find_len;
		end loop;
	end loop;
	-- нашли?
	if found_tab.count = 0 then
		return b;
	end if;
	-- ...да - новый BLOB
	dbms_lob.createtemporary(res, true);
	-- сортировка таблицы
	sort_found(found_tab, true);
	-- обход
	for i in 1..found_tab.count loop
		frec := found_tab(i);
		-- копирование до следующего вхождения
		if frec.offs > offs_src then
			len := frec.offs - offs_src;
			dbms_lob.copy(res, b, len, offs_dst, offs_src);
			offs_dst := offs_dst + len;
			offs_src := frec.offs;
		end if;
		-- замена вхождения
		pair := pairs_tab(frec.pair_idx);
		dbms_lob.writeappend(res, pair.repl_len, pair.repl);
		offs_dst := offs_dst + pair.repl_len;
		offs_src := offs_src + pair.find_len;
	end loop;
	-- копирование "хвоста"
	len := dbms_lob.getlength(b);
	if len > offs_src then
		len := len - offs_src + 1;
		dbms_lob.copy(res, b, len, offs_dst, offs_src);
		offs_dst := offs_dst + len;
		offs_src := frec.offs;
	end if;
	return res;
end;

/**
 * Поиск и замена в BLOB. Выполняется одиночный поиск и замена.
 * Только для одиночной замены! При необходимости выполнения нескольких последовательных поисков с заменой
 * нужно воспользоваться версией blob_replace с таблицей пар поиск-замена.
 *
 * @param b BLOB, в котором выполняется поиск
 * @param find Искомая последовательность. Не должна превышать 2000 байт.
 * @param repl Последовательность для замены. Не должна превышать 2000 байт. Для удаления найденных вхождений find установить значение NULL.
 * @return Результат замен в BLOB. Новый BLOB с заменами или исходный, если ничего не было найдено
 */
public function blob_replace(b BLOB, find raw, repl raw) return BLOB is
	tab T_BLOB_REPLACE_TAB;
begin
	push_replace_pair(tab, find, repl);
	return blob_replace(b, tab);
end;

--------------------------------------------------------

-- инициализация
begin
	gLOB_UTILS_size_limit := ::[FP_TUNE].[LIB].get_num_value('LOB_UTILS_SIZE_LIM', NULL, '0');
	executor.set_context('LOB_UTILS.SIZE_LIM', to_char(gLOB_UTILS_size_limit));
	l_slash := SysInfo.GetValue('DEF_SLASH');
end;

LOB_UTILS is

validate is
begin
	if P_MESSAGE = 'DEFAULT' then
		pragma error('Библиотека!');
	end if;
end;

execute is
begin
	pragma error('Библиотека!');
end;
end;
end;
